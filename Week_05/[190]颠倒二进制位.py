# 颠倒给定的 32 位无符号整数的二进制位。 
# 
#  
# 
#  示例 1： 
# 
#  输入: 00000010100101000001111010011100
# 输出: 00111001011110000010100101000000
# 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
#      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 
# 
#  示例 2： 
# 
#  输入：11111111111111111111111111111101
# 输出：10111111111111111111111111111111
# 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
#      因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。 
# 
#  
# 
#  提示： 
# 
#  
#  请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的
# 还是无符号的，其内部的二进制表示形式都是相同的。 
#  在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -10737418
# 25。 
#  
# 
#  
# 
#  进阶: 
# 如果多次调用这个函数，你将如何优化你的算法？ 
#  Related Topics 位运算 
#  👍 195 👎 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution:
    # @param n, an integer
    # @return an integer
    def reverseBits(self, n):
        """
        :param n:
        :return:
        """
        """
        逐位颠倒：32位,索引i位 移到 31-i
        1.检索整数的最右边的数，将其反转到正确的位置,添加到结果
        2.将二进制数向右移动一位
        3.迭代上述过程，直到 n == 0 
        复杂度分析：
        时间复杂度位O(1)
        """
        # res, power = 0, 31
        # while n:
        #     res += (n & 1) << power  # 取出n的最低位，左移，补0
        #     n >>= 1 # 右移，去掉刚刚的最低位
        #     power -= 1
        # return res

        # 方法二，不推荐
        return int(bin(n)[2:].zfill(32)[::-1], base=2)

if __name__ == '__main__':
    res, power = 0, 5
    n = 3
    while n:
        res += (n & 1) << power
        print(bin(res))
        n >>= 1
        power -= 1
    print(bin(res))
        
# leetcode submit region end(Prohibit modification and deletion)
